<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JavaScript学習ページ</title>
<script src="https://cdn.tailwindcss.com/3.4.16"></script>
<script>tailwind.config={theme:{extend:{colors:{primary:'#E6B800',secondary:'#323330'},borderRadius:{'none':'0px','sm':'4px',DEFAULT:'8px','md':'12px','lg':'16px','xl':'20px','2xl':'24px','3xl':'32px','full':'9999px','button':'8px'}}}}</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css">
<style>
:where([class^="ri-"])::before { content: "\f3c2"; }
body {
font-family: 'Inter', sans-serif;
}
h1, h2, h3, h4, h5, h6 {
font-family: 'Poppins', sans-serif;
}
.code-block {
background-color: #f8f8f8;
border-left: 4px solid #F7DF1E;
padding: 1rem;
margin: 1rem 0;
overflow-x: auto;
font-family: monospace;
}
.sidebar-link.active {
color: #323330;
background-color: rgba(247, 223, 30, 0.2);
border-left: 3px solid #F7DF1E;
}
.sidebar-link:hover {
background-color: rgba(247, 223, 30, 0.1);
}
@media (max-width: 768px) {
.sidebar {
transform: translateX(-100%);
transition: transform 0.3s ease;
}
.sidebar.open {
transform: translateX(0);
}
}
.slider .dot {
transition: transform 0.3s ease;
}
.slider.bg-primary .dot {
transform: translateX(16px);
}
.console-output {
background-color: #1e1e1e;
color: #f8f8f8;
font-family: monospace;
padding: 1rem;
border-radius: 8px;
}
.syntax-keyword {
color: #569cd6;
}
.syntax-string {
color: #ce9178;
}
.syntax-number {
color: #b5cea8;
}
.syntax-function {
color: #dcdcaa;
}
.syntax-comment {
color: #6a9955;
}
.syntax-operator {
color: #d4d4d4;
}
.syntax-variable {
color: #9cdcfe;
}
.range-slider {
-webkit-appearance: none;
width: 100%;
height: 6px;
border-radius: 5px;
background: #e0e0e0;
outline: none;
}
.range-slider::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 18px;
height: 18px;
border-radius: 50%;
background: #F7DF1E;
cursor: pointer;
}
.range-slider::-moz-range-thumb {
width: 18px;
height: 18px;
border-radius: 50%;
background: #F7DF1E;
cursor: pointer;
}
</style>
</head>
<body class="bg-white text-gray-800">
<!-- Mobile Header -->
<div class="md:hidden flex items-center justify-between p-4 border-b border-gray-200 bg-white sticky top-0 z-50">
<div class="flex items-center">
<button id="mobile-menu-button" class="w-10 h-10 flex items-center justify-center text-gray-700 mr-3">
<i class="ri-menu-line ri-lg"></i>
</button>
<div class="text-primary font-bold text-2xl">JavaScript</div>
</div>
</div>
<div class="flex flex-col md:flex-row min-h-screen md:pl-[250px]">
<!-- Left Sidebar with Logo and TOC -->
<div id="sidebar" class="sidebar fixed top-0 left-0 md:w-[250px] w-[280px] h-full bg-white border-r border-gray-200 overflow-y-auto z-40 md:translate-x-0">
<div class="p-6 border-b border-gray-200">
<div class="flex flex-col items-center">
<div class="w-32 h-32 flex items-center justify-center bg-primary rounded-lg mb-4">
<span class="text-white font-bold text-6xl">&lt;/&gt;</span>
</div>
<h1 class="text-primary font-bold text-3xl">JavaScript</h1>
</div>
</div>
<div class="p-4 border-b border-gray-200 flex justify-between items-center">
<h2 class="font-bold text-lg">目次</h2>
<button id="close-sidebar" class="md:hidden w-8 h-8 flex items-center justify-center text-gray-500">
<i class="ri-close-line ri-lg"></i>
</button>
</div>
<div class="p-4">
<div class="mb-6">
<h3 class="font-semibold text-sm uppercase text-gray-500 mb-2">JavaScript 基礎</h3>
<ul class="space-y-1">
<li><a href="#introduction" class="sidebar-link active block px-3 py-2 text-sm rounded-md">JavaScriptとは？</a></li>
<li><a href="#variables" class="sidebar-link block px-3 py-2 text-sm rounded-md">変数とデータ型</a></li>
<li><a href="#operators" class="sidebar-link block px-3 py-2 text-sm rounded-md">演算子</a></li>
<li><a href="#control-flow" class="sidebar-link block px-3 py-2 text-sm rounded-md">制御フロー</a></li>
</ul>
</div>
<div class="mb-6">
<h3 class="font-semibold text-sm uppercase text-gray-500 mb-2">JavaScript 関数</h3>
<ul class="space-y-1">
<li><a href="#function-basics" class="sidebar-link block px-3 py-2 text-sm rounded-md">関数の基本</a></li>
<li><a href="#arrow-functions" class="sidebar-link block px-3 py-2 text-sm rounded-md">アロー関数</a></li>
<li><a href="#callbacks" class="sidebar-link block px-3 py-2 text-sm rounded-md">コールバック</a></li>
<li><a href="#promises" class="sidebar-link block px-3 py-2 text-sm rounded-md">プロミス</a></li>
</ul>
</div>
<div class="mb-6">
<h3 class="font-semibold text-sm uppercase text-gray-500 mb-2">JavaScript オブジェクト</h3>
<ul class="space-y-1">
<li><a href="#object-basics" class="sidebar-link block px-3 py-2 text-sm rounded-md">オブジェクトの基本</a></li>
<li><a href="#arrays" class="sidebar-link block px-3 py-2 text-sm rounded-md">配列</a></li>
<li><a href="#dom" class="sidebar-link block px-3 py-2 text-sm rounded-md">DOM操作</a></li>
<li><a href="#events" class="sidebar-link block px-3 py-2 text-sm rounded-md">イベント</a></li>
</ul>
</div>
<div>
<h3 class="font-semibold text-sm uppercase text-gray-500 mb-2">高度なJavaScript</h3>
<ul class="space-y-1">
<li><a href="#async-await" class="sidebar-link block px-3 py-2 text-sm rounded-md">Async/Await</a></li>
<li><a href="#modules" class="sidebar-link block px-3 py-2 text-sm rounded-md">モジュール</a></li>
<li><a href="#error-handling" class="sidebar-link block px-3 py-2 text-sm rounded-md">エラー処理</a></li>
<li><a href="#best-practices" class="sidebar-link block px-3 py-2 text-sm rounded-md">ベストプラクティス</a></li>
</ul>
</div>
</div>
</div>
<!-- Main Content Area -->
<div class="flex-1 p-4 md:p-8 overflow-auto">
<div class="max-w-3xl mx-auto">
<div class="md:hidden mb-6">
<div class="flex justify-center mb-4">
<div class="w-24 h-24 flex items-center justify-center bg-primary rounded-lg">
<span class="text-white font-bold text-4xl">&lt;/&gt;</span>
</div>
</div>
<h1 class="text-primary font-bold text-2xl text-center mb-2">JavaScript</h1>
<p class="text-gray-600 text-sm text-center">ウェブ開発の基礎を学ぼう</p>
</div>
<section id="introduction" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">JavaScriptとは？</h2>
<p class="mb-4 leading-relaxed">JavaScriptは、ウェブページに動的な機能を追加するためのプログラミング言語です。HTML（構造）とCSS（スタイル）と組み合わせて使用され、インタラクティブなウェブサイトやウェブアプリケーションを作成することができます。</p>
<p class="mb-4 leading-relaxed">JavaScriptは当初、ブラウザ上でのみ実行されるクライアントサイドの言語でしたが、現在ではNode.jsなどの環境を通じてサーバーサイドでも使用されています。</p>
<div class="bg-gray-50 p-4 rounded-lg my-6 border border-gray-200">
<h3 class="text-lg font-semibold mb-2">JavaScriptの基本構造</h3>
<div class="code-block">
<pre>// 変数の宣言
let message = "こんにちは、世界！";
// 関数の定義
function showMessage() {
console.log(message);
}
// 関数の呼び出し
showMessage();</pre>
</div>
</div>
<div class="flex flex-col md:flex-row gap-4 mt-6">
<div class="flex-1 bg-gray-50 p-4 rounded-lg border border-gray-200">
<h4 class="font-semibold text-primary mb-2">JavaScriptの特徴</h4>
<ul class="list-disc pl-5 space-y-2">
<li>動的型付け言語</li>
<li>関数型プログラミングをサポート</li>
<li>プロトタイプベースのオブジェクト指向</li>
<li>イベント駆動型のプログラミング</li>
</ul>
</div>
<div class="flex-1 bg-gray-50 p-4 rounded-lg border border-gray-200">
<h4 class="font-semibold text-primary mb-2">JavaScriptの適用方法</h4>
<ul class="list-disc pl-5 space-y-2">
<li>インラインスクリプト（HTML要素の属性に直接記述）</li>
<li>内部スクリプト（HTMLファイル内のscriptタグ）</li>
<li>外部スクリプト（別ファイルのJSを読み込み）</li>
</ul>
</div>
</div>
</section>
<section id="variables" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">変数とデータ型</h2>
<p class="mb-4 leading-relaxed">JavaScriptでは、変数を使用してデータを保存し、後で参照することができます。変数を宣言するには、<code>var</code>、<code>let</code>、<code>const</code>キーワードを使用します。</p>
<div class="bg-gray-50 p-4 rounded-lg my-6 border border-gray-200">
<h3 class="text-lg font-semibold mb-2">変数宣言の例</h3>
<div class="code-block">
<pre>// varを使用した変数宣言（古い方法）
var name = "山田太郎";
// letを使用した変数宣言（推奨）
let age = 30;
// constを使用した定数宣言（値の再代入不可）
const PI = 3.14159;</pre>
</div>
</div>
<h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">JavaScriptのデータ型</h3>
<div class="space-y-6">
<div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
<h4 class="font-semibold text-primary mb-2">プリミティブ型</h4>
<p class="mb-2">基本的なデータ型で、値そのものが格納されます。</p>
<div class="code-block">
<pre>// 文字列
let name = "佐藤花子";
// 数値
let age = 25;
let price = 1299.99;
// 真偽値
let isActive = true;
// undefined（値が割り当てられていない）
let user;
// null（意図的に値がない）
let selectedItem = null;
// Symbol（ES6で追加された一意の値）
let id = Symbol("id");</pre>
</div>
</div>
<div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
<h4 class="font-semibold text-primary mb-2">参照型</h4>
<p class="mb-2">複雑なデータ構造で、メモリ内の参照が格納されます。</p>
<div class="code-block">
<pre>// オブジェクト
let person = {
name: "田中次郎",
age: 28,
isStudent: false
};
// 配列
let colors = ["赤", "青", "緑"];
// 関数
function greet() {
return "こんにちは";
}
// 日付
let today = new Date();</pre>
</div>
</div>
<div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
<h4 class="font-semibold text-primary mb-2">型の確認</h4>
<p class="mb-2"><code>typeof</code>演算子を使用して、変数のデータ型を確認できます。</p>
<div class="code-block">
<pre>let name = "鈴木一郎";
let age = 35;
let isActive = true;
let user = null;
let colors = ["赤", "青", "緑"];
console.log(typeof name);      // "string"
console.log(typeof age);       // "number"
console.log(typeof isActive);  // "boolean"
console.log(typeof user);      // "object"（JavaScriptの仕様上の問題）
console.log(typeof colors);    // "object"</pre>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mt-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">変数のスコープ</h3>
<p class="mb-3">変数のスコープとは、変数がアクセス可能な範囲を指します。</p>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">グローバルスコープ</h4>
<p class="mt-2 text-gray-600">関数の外部で宣言された変数は、コード全体からアクセス可能です。</p>
<div class="mt-2 code-block">
<pre>let globalVar = "グローバル変数";
function showVar() {
console.log(globalVar); // "グローバル変数"が出力される
}
showVar();</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">ローカルスコープ</h4>
<p class="mt-2 text-gray-600">関数内で宣言された変数は、その関数内でのみアクセス可能です。</p>
<div class="mt-2 code-block">
<pre>function showLocalVar() {
let localVar = "ローカル変数";
console.log(localVar); // "ローカル変数"が出力される
}
showLocalVar();
// console.log(localVar); // エラー: localVarは定義されていない</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">ブロックスコープ</h4>
<p class="mt-2 text-gray-600"><code>let</code>と<code>const</code>で宣言された変数は、宣言されたブロック内でのみアクセス可能です。</p>
<div class="mt-2 code-block">
<pre>if (true) {
let blockVar = "ブロック変数";
console.log(blockVar); // "ブロック変数"が出力される
}
// console.log(blockVar); // エラー: blockVarは定義されていない</pre>
</div>
</div>
</div>
</div>
</section>
<section id="operators" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">演算子</h2>
<p class="mb-4 leading-relaxed">JavaScriptには、値を操作するための様々な演算子があります。これらの演算子を使用して、計算、比較、論理操作などを行うことができます。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">算術演算子</h3>
<p class="mb-3">数値の計算を行うための演算子です。</p>
<div class="overflow-x-auto">
<table class="w-full border-collapse border border-gray-300 my-4">
<thead>
<tr class="bg-gray-100">
<th class="border border-gray-300 p-2 text-left">演算子</th>
<th class="border border-gray-300 p-2 text-left">説明</th>
<th class="border border-gray-300 p-2 text-left">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="border border-gray-300 p-2">+</td>
<td class="border border-gray-300 p-2">加算</td>
<td class="border border-gray-300 p-2 font-mono">5 + 2 = 7</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">-</td>
<td class="border border-gray-300 p-2">減算</td>
<td class="border border-gray-300 p-2 font-mono">5 - 2 = 3</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">*</td>
<td class="border border-gray-300 p-2">乗算</td>
<td class="border border-gray-300 p-2 font-mono">5 * 2 = 10</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">/</td>
<td class="border border-gray-300 p-2">除算</td>
<td class="border border-gray-300 p-2 font-mono">5 / 2 = 2.5</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">%</td>
<td class="border border-gray-300 p-2">剰余（余り）</td>
<td class="border border-gray-300 p-2 font-mono">5 % 2 = 1</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">**</td>
<td class="border border-gray-300 p-2">べき乗</td>
<td class="border border-gray-300 p-2 font-mono">5 ** 2 = 25</td>
</tr>
</tbody>
</table>
</div>
<div class="code-block">
<pre>let a = 10;
let b = 3;
console.log(a + b);  // 13
console.log(a - b);  // 7
console.log(a * b);  // 30
console.log(a / b);  // 3.3333...
console.log(a % b);  // 1
console.log(a ** b); // 1000</pre>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">比較演算子</h3>
<p class="mb-3">値を比較し、真偽値（true/false）を返す演算子です。</p>
<div class="overflow-x-auto">
<table class="w-full border-collapse border border-gray-300 my-4">
<thead>
<tr class="bg-gray-100">
<th class="border border-gray-300 p-2 text-left">演算子</th>
<th class="border border-gray-300 p-2 text-left">説明</th>
<th class="border border-gray-300 p-2 text-left">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="border border-gray-300 p-2">==</td>
<td class="border border-gray-300 p-2">等しい（型変換あり）</td>
<td class="border border-gray-300 p-2 font-mono">5 == "5" → true</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">===</td>
<td class="border border-gray-300 p-2">厳密に等しい（型変換なし）</td>
<td class="border border-gray-300 p-2 font-mono">5 === "5" → false</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">!=</td>
<td class="border border-gray-300 p-2">等しくない（型変換あり）</td>
<td class="border border-gray-300 p-2 font-mono">5 != "6" → true</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">!==</td>
<td class="border border-gray-300 p-2">厳密に等しくない（型変換なし）</td>
<td class="border border-gray-300 p-2 font-mono">5 !== "5" → true</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">></td>
<td class="border border-gray-300 p-2">より大きい</td>
<td class="border border-gray-300 p-2 font-mono">5 > 3 → true</td>
</tr>
<tr>
<td class="border border-gray-300 p-2"><</td>
<td class="border border-gray-300 p-2">より小さい</td>
<td class="border border-gray-300 p-2 font-mono">5 < 3 → false</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">>=</td>
<td class="border border-gray-300 p-2">以上</td>
<td class="border border-gray-300 p-2 font-mono">5 >= 5 → true</td>
</tr>
<tr>
<td class="border border-gray-300 p-2"><=</td>
<td class="border border-gray-300 p-2">以下</td>
<td class="border border-gray-300 p-2 font-mono">5 <= 3 → false</td>
</tr>
</tbody>
</table>
</div>
<div class="code-block">
<pre>let x = 10;
let y = "10";
console.log(x == y);   // true（値が等しい）
console.log(x === y);  // false（型が異なる）
console.log(x != y);   // false
console.log(x !== y);  // true
console.log(x > 5);    // true
console.log(x < 5);    // false</pre>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">論理演算子</h3>
<p class="mb-3">真偽値を操作するための演算子です。</p>
<div class="overflow-x-auto">
<table class="w-full border-collapse border border-gray-300 my-4">
<thead>
<tr class="bg-gray-100">
<th class="border border-gray-300 p-2 text-left">演算子</th>
<th class="border border-gray-300 p-2 text-left">説明</th>
<th class="border border-gray-300 p-2 text-left">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="border border-gray-300 p-2">&&</td>
<td class="border border-gray-300 p-2">論理AND（両方がtrueならtrue）</td>
<td class="border border-gray-300 p-2 font-mono">true && true → true</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">||</td>
<td class="border border-gray-300 p-2">論理OR（どちらかがtrueならtrue）</td>
<td class="border border-gray-300 p-2 font-mono">true || false → true</td>
</tr>
<tr>
<td class="border border-gray-300 p-2">!</td>
<td class="border border-gray-300 p-2">論理NOT（真偽値を反転）</td>
<td class="border border-gray-300 p-2 font-mono">!true → false</td>
</tr>
</tbody>
</table>
</div>
<div class="code-block">
<pre>let isAdult = true;
let hasPermission = false;
console.log(isAdult && hasPermission);  // false
console.log(isAdult || hasPermission);  // true
console.log(!isAdult);                  // false</pre>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">その他の演算子</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">代入演算子</h4>
<div class="mt-2 code-block">
<pre>let x = 10;
x += 5;  // x = x + 5 と同じ（x は 15 になる）
x -= 3;  // x = x - 3 と同じ（x は 12 になる）
x *= 2;  // x = x * 2 と同じ（x は 24 になる）
x /= 4;  // x = x / 4 と同じ（x は 6 になる）</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">三項演算子</h4>
<p class="mt-2 text-gray-600">条件に基づいて値を返す簡潔な方法です。</p>
<div class="mt-2 code-block">
<pre>// 構文: 条件 ? 真の場合の値 : 偽の場合の値
let age = 20;
let status = age >= 18 ? "大人" : "子供";
console.log(status);  // "大人"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">インクリメント/デクリメント演算子</h4>
<div class="mt-2 code-block">
<pre>let count = 0;
count++;  // count = count + 1 と同じ（count は 1 になる）
count--;  // count = count - 1 と同じ（count は 0 になる）
// 前置と後置の違い
let a = 0;
let b = ++a;  // a をインクリメントしてから b に代入（a=1, b=1）
let c = 0;
let d = c++;  // c を d に代入してから c をインクリメント（c=1, d=0）</pre>
</div>
</div>
</div>
</div>
</section>
<section id="control-flow" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">制御フロー</h2>
<p class="mb-4 leading-relaxed">制御フローは、プログラムの実行順序を制御する構文です。条件分岐やループを使用して、特定の条件に基づいてコードを実行したり、繰り返し処理を行ったりすることができます。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">条件分岐</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">if文</h4>
<p class="mt-2 text-gray-600">条件が真の場合にコードブロックを実行します。</p>
<div class="mt-2 code-block">
<pre>let temperature = 25;
if (temperature > 30) {
console.log("暑いです！");
} else if (temperature > 20) {
console.log("快適な気温です。");
} else {
console.log("寒いです！");
}
// 出力: "快適な気温です。"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">switch文</h4>
<p class="mt-2 text-gray-600">式の値に基づいて異なるコードブロックを実行します。</p>
<div class="mt-2 code-block">
<pre>let day = "月曜日";
switch (day) {
case "月曜日":
console.log("週の始まりです。");
break;
case "金曜日":
console.log("週末が近いです！");
break;
case "土曜日":
case "日曜日":
console.log("週末です！");
break;
default:
console.log("平日です。");
}
// 出力: "週の始まりです。"</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">ループ</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">for ループ</h4>
<p class="mt-2 text-gray-600">指定された回数だけコードブロックを繰り返し実行します。</p>
<div class="mt-2 code-block">
<pre>// 基本的なforループ
for (let i = 0; i < 5; i++) {
console.log(i);
}
// 出力: 0, 1, 2, 3, 4
// 配列の要素に対するforループ
let fruits = ["りんご", "バナナ", "オレンジ"];
for (let i = 0; i < fruits.length; i++) {
console.log(fruits[i]);
}
// 出力: "りんご", "バナナ", "オレンジ"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">for...of ループ</h4>
<p class="mt-2 text-gray-600">イテラブルオブジェクト（配列など）の各要素に対してループを実行します。</p>
<div class="mt-2 code-block">
<pre>let fruits = ["りんご", "バナナ", "オレンジ"];
for (let fruit of fruits) {
console.log(fruit);
}
// 出力: "りんご", "バナナ", "オレンジ"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">for...in ループ</h4>
<p class="mt-2 text-gray-600">オブジェクトのプロパティに対してループを実行します。</p>
<div class="mt-2 code-block">
<pre>let person = {
name: "高橋健太",
age: 32,
job: "エンジニア"
};
for (let key in person) {
console.log(key + ": " + person[key]);
}
// 出力: "name: 高橋健太", "age: 32", "job: エンジニア"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">while ループ</h4>
<p class="mt-2 text-gray-600">条件が真である限り、コードブロックを繰り返し実行します。</p>
<div class="mt-2 code-block">
<pre>let i = 0;
while (i < 5) {
console.log(i);
i++;
}
// 出力: 0, 1, 2, 3, 4</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">do...while ループ</h4>
<p class="mt-2 text-gray-600">コードブロックを1回実行した後、条件が真である限り繰り返し実行します。</p>
<div class="mt-2 code-block">
<pre>let i = 0;
do {
console.log(i);
i++;
} while (i < 5);
// 出力: 0, 1, 2, 3, 4</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">制御フローの中断</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">break</h4>
<p class="mt-2 text-gray-600">ループやswitch文から即座に抜け出します。</p>
<div class="mt-2 code-block">
<pre>for (let i = 0; i < 10; i++) {
if (i === 5) {
break; // i が 5 になったらループを終了
}
console.log(i);
}
// 出力: 0, 1, 2, 3, 4</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">continue</h4>
<p class="mt-2 text-gray-600">現在のループの反復をスキップして、次の反復に進みます。</p>
<div class="mt-2 code-block">
<pre>for (let i = 0; i < 10; i++) {
if (i % 2 === 0) {
continue; // i が偶数の場合、この反復をスキップ
}
console.log(i);
}
// 出力: 1, 3, 5, 7, 9</pre>
</div>
</div>
</div>
</div>
</section>
<section id="function-basics" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">関数の基本</h2>
<p class="mb-4 leading-relaxed">関数は、特定のタスクを実行するためのコードブロックです。関数を使用することで、コードを再利用し、プログラムを整理することができます。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">関数の定義と呼び出し</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">関数宣言</h4>
<div class="mt-2 code-block">
<pre>function greet(name) {
return "こんにちは、" + name + "さん！";
}
// 関数の呼び出し
let message = greet("中村");
console.log(message); // "こんにちは、中村さん！"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">関数式</h4>
<div class="mt-2 code-block">
<pre>const greet = function(name) {
return "こんにちは、" + name + "さん！";
};
// 関数の呼び出し
console.log(greet("田中")); // "こんにちは、田中さん！"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">パラメータとデフォルト値</h4>
<div class="mt-2 code-block">
<pre>function greet(name = "ゲスト") {
return "こんにちは、" + name + "さん！";
}
console.log(greet());        // "こんにちは、ゲストさん！"
console.log(greet("佐藤")); // "こんにちは、佐藤さん！"</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">関数のスコープと変数</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">ローカル変数とグローバル変数</h4>
<div class="mt-2 code-block">
<pre>// グローバル変数
let globalVar = "グローバル";
function testScope() {
// ローカル変数
let localVar = "ローカル";
console.log(globalVar); // "グローバル"（グローバル変数にアクセス可能）
console.log(localVar);  // "ローカル"
}
testScope();
console.log(globalVar); // "グローバル"
// console.log(localVar);  // エラー: localVarは定義されていない</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">クロージャ</h4>
<p class="mt-2 text-gray-600">クロージャは、関数が自身の外部のスコープにある変数を参照できる仕組みです。</p>
<div class="mt-2 code-block">
<pre>function createCounter() {
let count = 0;
return function() {
count++;
return count;
};
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">関数の高度な使い方</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">レスト引数</h4>
<p class="mt-2 text-gray-600">可変長の引数を配列として受け取ります。</p>
<div class="mt-2 code-block">
<pre>function sum(...numbers) {
let total = 0;
for (let number of numbers) {
total += number;
}
return total;
}
console.log(sum(1, 2, 3, 4, 5)); // 15</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">即時実行関数式（IIFE）</h4>
<p class="mt-2 text-gray-600">定義と同時に実行される関数です。</p>
<div class="mt-2 code-block">
<pre>(function() {
console.log("この関数は即座に実行されます");
})();
// 引数を渡す場合
(function(name) {
console.log("こんにちは、" + name + "さん！");
})("鈴木");</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">再帰関数</h4>
<p class="mt-2 text-gray-600">自分自身を呼び出す関数です。</p>
<div class="mt-2 code-block">
<pre>function factorial(n) {
if (n <= 1) {
return 1;
}
return n * factorial(n - 1);
}
console.log(factorial(5)); // 120 (5 * 4 * 3 * 2 * 1)</pre>
</div>
</div>
</div>
</div>
</section>
<section id="arrow-functions" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">アロー関数</h2>
<p class="mb-4 leading-relaxed">アロー関数は、ES6（ECMAScript 2015）で導入された、より簡潔な関数の書き方です。従来の関数式と比較して、より短く記述でき、<code>this</code>の扱いも異なります。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">アロー関数の構文</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520arrow%2520function%2520syntax%2520diagram%2520with%2520clean%2520code%2520examples%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520highlights%2520on%2520white%2520background&width=800&height=300&seq=1&orientation=landscape" alt="Arrow Function Syntax" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">基本的なアロー関数</h4>
<div class="mt-2 code-block">
<pre>// 従来の関数式
const add = function(a, b) {
return a + b;
};
// アロー関数
const add = (a, b) => {
return a + b;
};
// 単一の式の場合、中括弧とreturnを省略可能
const add = (a, b) => a + b;</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">引数が1つの場合</h4>
<div class="mt-2 code-block">
<pre>// 引数が1つの場合、括弧を省略可能
const square = x => x * x;
console.log(square(5)); // 25</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">引数がない場合</h4>
<div class="mt-2 code-block">
<pre>// 引数がない場合は空の括弧が必要
const sayHello = () => "こんにちは！";
console.log(sayHello()); // "こんにちは！"</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">アロー関数と<code>this</code></h3>
<p class="mb-3">アロー関数の最大の特徴の1つは、独自の<code>this</code>を持たないことです。アロー関数内の<code>this</code>は、関数が定義されたコンテキストの<code>this</code>を継承します。</p>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">従来の関数と<code>this</code></h4>
<div class="mt-2 code-block">
<pre>const person = {
name: "山田太郎",
sayHello: function() {
console.log("こんにちは、" + this.name + "です！");
}
};
person.sayHello(); // "こんにちは、山田太郎です！"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">アロー関数と<code>this</code></h4>
<div class="mt-2 code-block">
<pre>const person = {
name: "山田太郎",
sayHello: function() {
// 従来の関数内での setTimeout
setTimeout(function() {
console.log("こんにちは、" + this.name + "です！"); // this はグローバルオブジェクトを参照
}, 1000);
// アロー関数を使用した setTimeout
setTimeout(() => {
console.log("こんにちは、" + this.name + "です！"); // this は person オブジェクトを参照
}, 1000);
}
};
person.sayHello();</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">アロー関数の使用例</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">配列のメソッドとの組み合わせ</h4>
<div class="mt-2 code-block">
<pre>const numbers = [1, 2, 3, 4, 5];
// map メソッドで各要素を2倍にする
const doubled = numbers.map(x => x * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
// filter メソッドで偶数のみを抽出
const evens = numbers.filter(x => x % 2 === 0);
console.log(evens); // [2, 4]
// reduce メソッドで合計を計算
const sum = numbers.reduce((total, x) => total + x, 0);
console.log(sum); // 15</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">オブジェクトリテラルを返す</h4>
<p class="mt-2 text-gray-600">オブジェクトリテラルを返す場合は、括弧で囲む必要があります。</p>
<div class="mt-2 code-block">
<pre>const createPerson = (name, age) => ({ name, age });
const person = createPerson("佐藤花子", 28);
console.log(person); // { name: "佐藤花子", age: 28 }</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">アロー関数の制限</h4>
<p class="mt-2 text-gray-600">アロー関数には、いくつかの制限があります。</p>
<div class="mt-2 code-block">
<pre>// アロー関数はコンストラクタとして使用できない
const Person = (name) => {
this.name = name; // 動作しない
};
// const person = new Person("田中"); // エラー
// arguments オブジェクトにアクセスできない
const func = () => {
console.log(arguments); // エラーまたはundefined
};</pre>
</div>
</div>
</div>
</div>
</section>
<section id="callbacks" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">コールバック</h2>
<p class="mb-4 leading-relaxed">コールバックは、他の関数に引数として渡される関数です。特定のイベントが発生したときや、非同期処理が完了したときに実行されるように設計されています。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">コールバックの基本</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520callback%2520function%2520flow%2520diagram%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520arrows%2520showing%2520execution%2520flow%252C%2520clean%2520design%2520on%2520white%2520background&width=800&height=300&seq=2&orientation=landscape" alt="Callback Functions" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">シンプルなコールバック例</h4>
<div class="mt-2 code-block">
<pre>function greet(name, callback) {
console.log("こんにちは、" + name + "さん！");
callback();
}
// コールバック関数を定義
function sayGoodbye() {
console.log("さようなら！");
}
// コールバック関数を引数として渡す
greet("鈴木", sayGoodbye);
// 出力:
// "こんにちは、鈴木さん！"
// "さようなら！"
// 匿名関数をコールバックとして使用
greet("田中", function() {
console.log("また会いましょう！");
});
// 出力:
// "こんにちは、田中さん！"
// "また会いましょう！"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">引数を持つコールバック</h4>
<div class="mt-2 code-block">
<pre>function calculate(a, b, operation) {
return operation(a, b);
}
// 加算のコールバック
function add(x, y) {
return x + y;
}
// 乗算のコールバック
function multiply(x, y) {
return x * y;
}
console.log(calculate(5, 3, add));      // 8
console.log(calculate(5, 3, multiply)); // 15
// アロー関数を使用したコールバック
console.log(calculate(5, 3, (x, y) => x - y)); // 2</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">非同期処理とコールバック</h3>
<p class="mb-3">JavaScriptでは、非同期処理を扱うためにコールバックが広く使用されています。</p>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">setTimeout によるコールバック</h4>
<div class="mt-2 code-block">
<pre>console.log("処理を開始します");
setTimeout(function() {
console.log("3秒後に実行されます");
}, 3000);
console.log("処理を続行します");
// 出力:
// "処理を開始します"
// "処理を続行します"
// （3秒後）"3秒後に実行されます"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">イベントリスナーとしてのコールバック</h4>
<div class="mt-2 code-block">
<pre>// ボタンクリックイベントのリスナー
document.getElementById("myButton").addEventListener("click", function(event) {
console.log("ボタンがクリックされました！");
console.log(event);
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">非同期データ取得の例</h4>
<div class="mt-2 code-block">
<pre>function fetchData(callback) {
// データ取得の非同期処理を模倣
setTimeout(function() {
const data = { id: 1, name: "サンプルデータ" };
callback(null, data); // 成功時: エラーはnull、データを返す
}, 2000);
}
function handleData(error, data) {
if (error) {
console.error("エラーが発生しました:", error);
return;
}
console.log("データを取得しました:", data);
}
console.log("データの取得を開始します...");
fetchData(handleData);
console.log("他の処理を続行します...");
// 出力:
// "データの取得を開始します..."
// "他の処理を続行します..."
// （2秒後）"データを取得しました: { id: 1, name: 'サンプルデータ' }"</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">コールバック地獄とその解決策</h3>
<p class="mb-3">複数の非同期処理を連鎖させると、コードが深くネストされ、「コールバック地獄」と呼ばれる状態になることがあります。</p>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">コールバック地獄の例</h4>
<div class="mt-2 code-block">
<pre>fetchUserData(function(userData) {
fetchUserPosts(userData.id, function(posts) {
fetchPostComments(posts[0].id, function(comments) {
fetchCommentAuthor(comments[0].authorId, function(author) {
console.log("著者の情報:", author);
// さらにネストが続く...
});
});
});
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">解決策: 名前付き関数</h4>
<p class="mt-2 text-gray-600">コールバックを名前付き関数として定義し、ネストを減らす方法です。</p>
<div class="mt-2 code-block">
<pre>function handleAuthor(author) {
console.log("著者の情報:", author);
}
function handleComments(comments) {
fetchCommentAuthor(comments[0].authorId, handleAuthor);
}
function handlePosts(posts) {
fetchPostComments(posts[0].id, handleComments);
}
function handleUserData(userData) {
fetchUserPosts(userData.id, handlePosts);
}
fetchUserData(handleUserData);</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">解決策: Promise と async/await</h4>
<p class="mt-2 text-gray-600">より現代的なアプローチとして、PromiseやAsync/Awaitを使用することで、コールバック地獄を解消できます。</p>
<div class="mt-2 code-block">
<pre>// Promiseを使用した例
fetchUserData()
.then(userData => fetchUserPosts(userData.id))
.then(posts => fetchPostComments(posts[0].id))
.then(comments => fetchCommentAuthor(comments[0].authorId))
.then(author => {
console.log("著者の情報:", author);
})
.catch(error => {
console.error("エラーが発生しました:", error);
});
// async/awaitを使用した例
async function getAuthorInfo() {
try {
const userData = await fetchUserData();
const posts = await fetchUserPosts(userData.id);
const comments = await fetchPostComments(posts[0].id);
const author = await fetchCommentAuthor(comments[0].authorId);
console.log("著者の情報:", author);
} catch (error) {
console.error("エラーが発生しました:", error);
}
}
getAuthorInfo();</pre>
</div>
</div>
</div>
</div>
</section>
<section id="promises" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">プロミス</h2>
<p class="mb-4 leading-relaxed">プロミス（Promise）は、JavaScriptにおける非同期処理を扱うためのオブジェクトです。コールバック関数を使用する代わりに、より構造化された方法で非同期処理の結果を扱うことができます。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">プロミスの基本</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520promise%2520state%2520diagram%2520showing%2520pending%252C%2520fulfilled%2520and%2520rejected%2520states%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520flow%2520arrows%252C%2520clean%2520design%2520on%2520white%2520background&width=800&height=300&seq=3&orientation=landscape" alt="Promise States" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<p class="mb-3">プロミスは以下の3つの状態のいずれかを持ちます：</p>
<ul class="list-disc pl-5 space-y-2 mb-4">
<li><strong>Pending（保留中）</strong>: 初期状態、処理が完了していない</li>
<li><strong>Fulfilled（成功）</strong>: 処理が成功して完了した</li>
<li><strong>Rejected（拒否）</strong>: 処理が失敗した</li>
</ul>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">プロミスの作成</h4>
<div class="mt-2 code-block">
<pre>const myPromise = new Promise((resolve, reject) => {
// 非同期処理を実行
const success = true; // 成功か失敗かを判断するフラグ
if (success) {
// 成功した場合
resolve("処理が成功しました！");
} else {
// 失敗した場合
reject("エラーが発生しました");
}
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">プロミスの使用</h4>
<div class="mt-2 code-block">
<pre>myPromise
.then((result) => {
// 成功時の処理
console.log(result); // "処理が成功しました！"
})
.catch((error) => {
// 失敗時の処理
console.error(error);
})
.finally(() => {
// 成功・失敗に関わらず実行される処理
console.log("処理が完了しました");
});</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">プロミスチェーン</h3>
<p class="mb-3">プロミスは連鎖させることができ、非同期処理を順番に実行できます。</p>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">プロミスチェーンの例</h4>
<div class="mt-2 code-block">
<pre>fetchUserData(userId)
.then(userData => {
console.log("ユーザー情報:", userData);
return fetchUserPosts(userData.id); // 新しいプロミスを返す
})
.then(posts => {
console.log("ユーザーの投稿:", posts);
return fetchPostComments(posts[0].id); // 新しいプロミスを返す
})
.then(comments => {
console.log("投稿へのコメント:", comments);
})
.catch(error => {
// チェーン内のどこかでエラーが発生した場合
console.error("エラーが発生しました:", error);
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">値の変換</h4>
<p class="mt-2 text-gray-600">プロミスチェーン内で値を変換することができます。</p>
<div class="mt-2 code-block">
<pre>fetch("https://api.example.com/data")
.then(response => response.json()) // レスポンスをJSONに変換
.then(data => {
// データを加工
return data.items.map(item => item.name);
})
.then(names => {
console.log("アイテム名:", names);
})
.catch(error => {
console.error("エラーが発生しました:", error);
});</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">プロミスの高度な使い方</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">Promise.all</h4>
<p class="mt-2 text-gray-600">複数のプロミスを並行して実行し、すべてが完了するのを待ちます。</p>
<div class="mt-2 code-block">
<pre>const promise1 = fetchUserData(1);
const promise2 = fetchUserData(2);
const promise3 = fetchUserData(3);
Promise.all([promise1, promise2, promise3])
.then(results => {
// すべてのプロミスが成功した場合
console.log("すべてのユーザーデータ:", results);
// results[0] は promise1 の結果
// results[1] は promise2 の結果
// results[2] は promise3 の結果
})
.catch(error => {
// いずれかのプロミスが失敗した場合
console.error("エラーが発生しました:", error);
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">Promise.race</h4>
<p class="mt-2 text-gray-600">複数のプロミスを並行して実行し、最初に完了したものの結果を返します。</p>
<div class="mt-2 code-block">
<pre>const promise1 = new Promise(resolve => setTimeout(() => resolve("1つ目"), 500));
const promise2 = new Promise(resolve => setTimeout(() => resolve("2つ目"), 100));
Promise.race([promise1, promise2])
.then(result => {
console.log("最初に完了したプロミス:", result); // "2つ目"
})
.catch(error => {
console.error("エラーが発生しました:", error);
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">Promise.allSettled</h4>
<p class="mt-2 text-gray-600">複数のプロミスを並行して実行し、すべてが成功または失敗するのを待ちます。</p>
<div class="mt-2 code-block">
<pre>const promise1 = Promise.resolve("成功");
const promise2 = Promise.reject("エラー");
const promise3 = Promise.resolve("別の成功");
Promise.allSettled([promise1, promise2, promise3])
.then(results => {
console.log(results);
// [
//   { status: "fulfilled", value: "成功" },
//   { status: "rejected", reason: "エラー" },
//   { status: "fulfilled", value: "別の成功" }
// ]
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">Promise.any</h4>
<p class="mt-2 text-gray-600">複数のプロミスを並行して実行し、最初に成功したものの結果を返します。</p>
<div class="mt-2 code-block">
<pre>const promise1 = Promise.reject("エラー1");
const promise2 = new Promise(resolve => setTimeout(() => resolve("成功"), 200));
const promise3 = Promise.reject("エラー2");
Promise.any([promise1, promise2, promise3])
.then(result => {
console.log("最初に成功したプロミス:", result); // "成功"
})
.catch(error => {
console.error("すべてのプロミスが失敗しました:", error);
});</pre>
</div>
</div>
</div>
</div>
</section>
<section id="object-basics" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">オブジェクトの基本</h2>
<p class="mb-4 leading-relaxed">JavaScriptのオブジェクトは、関連するデータと機能をまとめたコレクションです。キーと値のペアで構成され、複雑なデータ構造を表現するのに適しています。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">オブジェクトの作成と操作</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520object%2520structure%2520visualization%2520with%2520properties%2520and%2520methods%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520elements%252C%2520clean%2520design%2520on%2520white%2520background&width=800&height=300&seq=4&orientation=landscape" alt="JavaScript Objects" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">オブジェクトリテラル</h4>
<div class="mt-2 code-block">
<pre>// オブジェクトリテラルを使用してオブジェクトを作成
const person = {
firstName: "太郎",
lastName: "山田",
age: 30,
email: "taro.yamada@example.com",
isEmployed: true,
hobbies: ["読書", "旅行", "料理"],
address: {
street: "桜木町1-2-3",
city: "東京",
postalCode: "123-4567"
},
fullName: function() {
return this.lastName + " " + this.firstName;
}
};</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">オブジェクトのプロパティへのアクセス</h4>
<div class="mt-2 code-block">
<pre>// ドット記法
console.log(person.firstName); // "太郎"
console.log(person.address.city); // "東京"
// ブラケット記法
console.log(person["lastName"]); // "山田"
console.log(person["address"]["postalCode"]); // "123-4567"
// 変数を使用したプロパティアクセス
const propertyName = "age";
console.log(person[propertyName]); // 30</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">オブジェクトのメソッドの呼び出し</h4>
<div class="mt-2 code-block">
<pre>console.log(person.fullName()); // "山田 太郎"</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">オブジェクトの操作</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">プロパティの追加と変更</h4>
<div class="mt-2 code-block">
<pre>// 新しいプロパティの追加
person.phoneNumber = "090-1234-5678";
person["nationality"] = "日本";
// プロパティの変更
person.age = 31;
person["email"] = "newemail@example.com";</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">プロパティの削除</h4>
<div class="mt-2 code-block">
<pre>// delete演算子を使用してプロパティを削除
delete person.phoneNumber;
delete person["nationality"];</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">オブジェクトのプロパティの存在確認</h4>
<div class="mt-2 code-block">
<pre>// in演算子を使用
console.log("age" in person); // true
console.log("phoneNumber" in person); // false（削除されたため）
// hasOwnPropertyメソッドを使用
console.log(person.hasOwnProperty("email")); // true
console.log(person.hasOwnProperty("toString")); // false（プロトタイプのメソッド）</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">オブジェクトの高度な操作</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">オブジェクトのコピー</h4>
<div class="mt-2 code-block">
<pre>// 浅いコピー
const personCopy1 = Object.assign({}, person);
const personCopy2 = { ...person }; // スプレッド構文
// 深いコピー（ネストされたオブジェクトも含む）
const personDeepCopy = JSON.parse(JSON.stringify(person));</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">オブジェクトのマージ</h4>
<div class="mt-2 code-block">
<pre>const personalInfo = {
firstName: "太郎",
lastName: "山田",
age: 30
};
const contactInfo = {
email: "taro.yamada@example.com",
phone: "090-1234-5678"
};
// Object.assignを使用したマージ
const person1 = Object.assign({}, personalInfo, contactInfo);
// スプレッド構文を使用したマージ
const person2 = { ...personalInfo, ...contactInfo };</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">オブジェクトの反復処理</h4>
<div class="mt-2 code-block">
<pre>// for...inループを使用
for (let key in person) {
if (person.hasOwnProperty(key)) {
console.log(key + ": " + person[key]);
}
}
// Object.keysを使用
Object.keys(person).forEach(key => {
console.log(key + ": " + person[key]);
});
// Object.entriesを使用
Object.entries(person).forEach(([key, value]) => {
console.log(key + ": " + value);
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">オブジェクトの分割代入</h4>
<div class="mt-2 code-block">
<pre>// オブジェクトの分割代入
const { firstName, lastName, age } = person;
console.log(firstName); // "太郎"
console.log(lastName);  // "山田"
console.log(age);       // 30
// ネストされたオブジェクトの分割代入
const { address: { city, postalCode } } = person;
console.log(city);       // "東京"
console.log(postalCode); // "123-4567"
// 変数名の変更
const { firstName: first, lastName: last } = person;
console.log(first); // "太郎"
console.log(last);  // "山田"</pre>
</div>
</div>
</div>
</div>
</section>
<section id="arrays" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">配列</h2>
<p class="mb-4 leading-relaxed">配列は、順序付けられたデータのコレクションです。JavaScriptの配列は、異なる型の要素を含むことができ、サイズも動的に変更できます。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">配列の作成と操作</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520array%2520methods%2520visualization%2520with%2520push%252C%2520pop%252C%2520shift%252C%2520unshift%2520operations%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520elements%252C%2520clean%2520design%2520on%2520white%2520background&width=800&height=300&seq=5&orientation=landscape" alt="JavaScript Arrays" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">配列の作成</h4>
<div class="mt-2 code-block">
<pre>// 配列リテラルを使用
const fruits = ["りんご", "バナナ", "オレンジ"];
// Array コンストラクタを使用
const numbers = new Array(1, 2, 3, 4, 5);
// 空の配列を作成
const emptyArray = [];
// 異なる型の要素を含む配列
const mixedArray = [1, "テキスト", true, null, { name: "オブジェクト" }, [1, 2, 3]];</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">配列要素へのアクセス</h4>
<div class="mt-2 code-block">
<pre>const fruits = ["りんご", "バナナ", "オレンジ", "ぶどう"];
// インデックスを使用して要素にアクセス（0から始まる）
console.log(fruits[0]); // "りんご"
console.log(fruits[2]); // "オレンジ"
// 存在しないインデックスにアクセス
console.log(fruits[10]); // undefined
// 配列の長さを取得
console.log(fruits.length); // 4
// 最後の要素にアクセス
console.log(fruits[fruits.length - 1]); // "ぶどう"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">配列の変更</h4>
<div class="mt-2 code-block">
<pre>const fruits = ["りんご", "バナナ", "オレンジ"];
// 要素の変更
fruits[1] = "いちご";
console.log(fruits); // ["りんご", "いちご", "オレンジ"]
// 配列の末尾に要素を追加
fruits.push("キウイ");
console.log(fruits); // ["りんご", "いちご", "オレンジ", "キウイ"]
// 配列の先頭に要素を追加
fruits.unshift("メロン");
console.log(fruits); // ["メロン", "りんご", "いちご", "オレンジ", "キウイ"]
// 配列の末尾から要素を削除
const lastFruit = fruits.pop();
console.log(lastFruit); // "キウイ"
console.log(fruits); // ["メロン", "りんご", "いちご", "オレンジ"]
// 配列の先頭から要素を削除
const firstFruit = fruits.shift();
console.log(firstFruit); // "メロン"
console.log(fruits); // ["りんご", "いちご", "オレンジ"]</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">配列の操作メソッド</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">splice - 要素の追加・削除</h4>
<div class="mt-2 code-block">
<pre>const fruits = ["りんご", "バナナ", "オレンジ", "ぶどう"];
// インデックス1から2つの要素を削除し、新しい要素を追加
const removed = fruits.splice(1, 2, "いちご", "メロン");
console.log(removed); // ["バナナ", "オレンジ"]
console.log(fruits);  // ["りんご", "いちご", "メロン", "ぶどう"]
// 要素の削除のみ
fruits.splice(2, 1);
console.log(fruits); // ["りんご", "いちご", "ぶどう"]
// 要素の追加のみ（削除数を0に設定）
fruits.splice(1, 0, "キウイ");
console.log(fruits); // ["りんご", "キウイ", "いちご", "ぶどう"]</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">slice - 配列の一部を取得</h4>
<div class="mt-2 code-block">
<pre>const fruits = ["りんご", "バナナ", "オレンジ", "ぶどう", "メロン"];
// インデックス1から3の手前までの要素を取得
const sliced = fruits.slice(1, 3);
console.log(sliced); // ["バナナ", "オレンジ"]
// 元の配列は変更されない
console.log(fruits); // ["りんご", "バナナ", "オレンジ", "ぶどう", "メロン"]
// 開始インデックスのみを指定（そこから最後まで）
const fromIndex2 = fruits.slice(2);
console.log(fromIndex2); // ["オレンジ", "ぶどう", "メロン"]
// 負のインデックスを使用（末尾からのカウント）
const lastTwo = fruits.slice(-2);
console.log(lastTwo); // ["ぶどう", "メロン"]</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">concat - 配列の結合</h4>
<div class="mt-2 code-block">
<pre>const fruits = ["りんご", "バナナ"];
const moreFruits = ["オレンジ", "ぶどう"];
// 2つの配列を結合
const allFruits = fruits.concat(moreFruits);
console.log(allFruits); // ["りんご", "バナナ", "オレンジ", "ぶどう"]
// 複数の配列と値を結合
const evenMoreFruits = fruits.concat(moreFruits, ["メロン"], "パイナップル");
console.log(evenMoreFruits); // ["りんご", "バナナ", "オレンジ", "ぶどう", "メロン", "パイナップル"]</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">join - 配列を文字列に変換</h4>
<div class="mt-2 code-block">
<pre>const fruits = ["りんご", "バナナ", "オレンジ"];
// デフォルトの区切り文字（カンマ）
const fruitsString = fruits.join();
console.log(fruitsString); // "りんご,バナナ,オレンジ"
// カスタム区切り文字
const fruitsWithSeparator = fruits.join(" と ");
console.log(fruitsWithSeparator); // "りんご と バナナ と オレンジ"
// 区切り文字なし
const fruitsWithoutSeparator = fruits.join("");
console.log(fruitsWithoutSeparator); // "りんごバナナオレンジ"</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">配列の反復処理と高階関数</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">forEach - 各要素に対して処理を実行</h4>
<div class="mt-2 code-block">
<pre>const fruits = ["りんご", "バナナ", "オレンジ"];
fruits.forEach((fruit, index) => {
console.log(`${index}: ${fruit}`);
});
// 出力:
// "0: りんご"
// "1: バナナ"
// "2: オレンジ"</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">map - 各要素を変換して新しい配列を作成</h4>
<div class="mt-2 code-block">
<pre>const numbers = [1, 2, 3, 4, 5];
// 各数値を2倍にする
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
// オブジェクトの配列を変換
const persons = [
{ firstName: "太郎", lastName: "山田" },
{ firstName: "花子", lastName: "佐藤" }
];
const fullNames = persons.map(person => `${person.lastName} ${person.firstName}`);
console.log(fullNames); // ["山田 太郎", "佐藤 花子"]</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">filter - 条件に合う要素だけを抽出</h4>
<div class="mt-2 code-block">
<pre>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// 偶数のみを抽出
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6, 8, 10]
// 特定の条件に合うオブジェクトを抽出
const products = [
{ name: "ノートPC", price: 80000, inStock: true },
{ name: "タブレット", price: 50000, inStock: false },
{ name: "スマートフォン", price: 60000, inStock: true },
{ name: "ヘッドフォン", price: 20000, inStock: true }
];
const availableProducts = products.filter(product => product.inStock && product.price < 70000);
console.log(availableProducts);
// [
//   { name: "スマートフォン", price: 60000, inStock: true },
//   { name: "ヘッドフォン", price: 20000, inStock: true }
// ]</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">reduce - 配列を単一の値に集約</h4>
<div class="mt-2 code-block">
<pre>const numbers = [1, 2, 3, 4, 5];
// 合計を計算
const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
console.log(sum); // 15
// 最大値を見つける
const max = numbers.reduce((max, current) => Math.max(max, current), -Infinity);
console.log(max); // 5
// オブジェクトの集計
const sales = [
{ product: "ノートPC", amount: 80000 },
{ product: "タブレット", amount: 50000 },
{ product: "ノートPC", amount: 70000 },
{ product: "スマートフォン", amount: 60000 }
];
const salesByProduct = sales.reduce((result, item) => {
if (!result[item.product]) {
result[item.product] = 0;
}
result[item.product] += item.amount;
return result;
}, {});
console.log(salesByProduct);
// {
//   "ノートPC": 150000,
//   "タブレット": 50000,
//   "スマートフォン": 60000
// }</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">find と findIndex - 条件に合う要素を検索</h4>
<div class="mt-2 code-block">
<pre>const products = [
{ id: 1, name: "ノートPC", price: 80000 },
{ id: 2, name: "タブレット", price: 50000 },
{ id: 3, name: "スマートフォン", price: 60000 }
];
// 条件に合う最初の要素を見つける
const tablet = products.find(product => product.name === "タブレット");
console.log(tablet); // { id: 2, name: "タブレット", price: 50000 }
// 条件に合う最初の要素のインデックスを見つける
const smartphoneIndex = products.findIndex(product => product.name === "スマートフォン");
console.log(smartphoneIndex); // 2</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">some と every - 条件の確認</h4>
<div class="mt-2 code-block">
<pre>const numbers = [1, 2, 3, 4, 5];
// いずれかの要素が条件を満たすか
const hasEven = numbers.some(num => num % 2 === 0);
console.log(hasEven); // true
// すべての要素が条件を満たすか
const allPositive = numbers.every(num => num > 0);
console.log(allPositive); // true
const allEven = numbers.every(num => num % 2 === 0);
console.log(allEven); // false</pre>
</div>
</div>
</div>
</div>
</section>
<section id="dom" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">DOM操作</h2>
<p class="mb-4 leading-relaxed">DOM（Document Object Model）は、HTMLドキュメントをプログラムから操作するためのインターフェースです。JavaScriptを使用して、ウェブページの要素を追加、変更、削除することができます。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">DOM要素の選択</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520DOM%2520manipulation%2520visualization%2520showing%2520HTML%2520document%2520tree%2520structure%2520with%2520elements%2520being%2520selected%2520and%2520modified%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520highlights%2520on%2520white%2520background&width=800&height=300&seq=6&orientation=landscape" alt="DOM Manipulation" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">IDによる要素の選択</h4>
<div class="mt-2 code-block">
<pre>// ID "myElement" を持つ要素を取得
const element = document.getElementById("myElement");</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">クラスによる要素の選択</h4>
<div class="mt-2 code-block">
<pre>// クラス "myClass" を持つすべての要素を取得
const elements = document.getElementsByClassName("myClass");
// HTMLCollectionが返される（配列のようなオブジェクト）
for (let i = 0; i < elements.length; i++) {
console.log(elements[i]);
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">タグ名による要素の選択</h4>
<div class="mt-2 code-block">
<pre>// すべての段落要素を取得
const paragraphs = document.getElementsByTagName("p");</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">CSSセレクタによる要素の選択</h4>
<div class="mt-2 code-block">
<pre>// 最初にマッチする要素を取得
const element = document.querySelector(".container p");
// マッチするすべての要素を取得
const elements = document.querySelectorAll(".container p");
// NodeListが返される（配列のようなオブジェクト）
elements.forEach(element => {
console.log(element);
});</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">DOM要素の操作</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">コンテンツの変更</h4>
<div class="mt-2 code-block">
<pre>// テキストコンテンツの変更
element.textContent = "新しいテキスト";
// HTML内容の変更
element.innerHTML = "&lt;strong&gt;新しいHTML&lt;/strong&gt;";
// 要素の値を変更（input要素など）
document.getElementById("myInput").value = "新しい値";</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">属性の操作</h4>
<div class="mt-2 code-block">
<pre>// 属性の取得
const src = element.getAttribute("src");
// 属性の設定
element.setAttribute("href", "https://example.com");
// 属性の削除
element.removeAttribute("disabled");
// 属性の存在確認
const hasAttribute = element.hasAttribute("class");</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">クラスの操作</h4>
<div class="mt-2 code-block">
<pre>// クラスの追加
element.classList.add("active");
// クラスの削除
element.classList.remove("disabled");
// クラスの切り替え（あれば削除、なければ追加）
element.classList.toggle("highlight");
// クラスの存在確認
const hasClass = element.classList.contains("selected");</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">スタイルの操作</h4>
<div class="mt-2 code-block">
<pre>// インラインスタイルの設定
element.style.color = "blue";
element.style.fontSize = "16px";
element.style.display = "none";
// 複数のスタイルをまとめて設定
Object.assign(element.style, {
color: "white",
backgroundColor: "black",
padding: "10px"
});</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">DOM要素の作成と追加</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">新しい要素の作成</h4>
<div class="mt-2 code-block">
<pre>// 新しい要素を作成
const newParagraph = document.createElement("p");
// テキストノードを作成
const textNode = document.createTextNode("これは新しい段落です。");
// テキストノードを要素に追加
newParagraph.appendChild(textNode);
// または直接テキストを設定
newParagraph.textContent = "これは新しい段落です。";</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">要素の追加</h4>
<div class="mt-2 code-block">
<pre>// 親要素の末尾に子要素を追加
parentElement.appendChild(newElement);
// 特定の要素の前に挿入
parentElement.insertBefore(newElement, referenceElement);
// 最新のメソッド
parentElement.append(newElement);  // 末尾に追加
parentElement.prepend(newElement); // 先頭に追加
referenceElement.before(newElement); // 前に挿入
referenceElement.after(newElement);  // 後に挿入</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">要素の削除と置換</h4>
<div class="mt-2 code-block">
<pre>// 要素の削除
element.remove();
// 親要素から子要素を削除
parentElement.removeChild(childElement);
// 要素の置換
parentElement.replaceChild(newElement, oldElement);</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">複数の要素を効率的に追加</h4>
<div class="mt-2 code-block">
<pre>// DocumentFragmentを使用して複数の要素を一度に追加
const fragment = document.createDocumentFragment();
for (let i = 0; i < 5; i++) {
const li = document.createElement("li");
li.textContent = `アイテム ${i + 1}`;
fragment.appendChild(li);
}
// フラグメント内のすべての要素を一度にDOMに追加
document.getElementById("myList").appendChild(fragment);</pre>
</div>
</div>
</div>
</div>
</section>
<section id="events" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">イベント</h2>
<p class="mb-4 leading-relaxed">イベントは、ユーザーのアクション（クリック、キー入力など）やシステムの状態変化（ページの読み込み完了など）に応じて発生します。JavaScriptを使用して、これらのイベントを監視し、特定のコードを実行することができます。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">イベントリスナーの追加</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520event%2520handling%2520visualization%2520showing%2520user%2520interactions%2520like%2520clicks%2520and%2520keyboard%2520input%2520triggering%2520events%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520highlights%2520on%2520white%2520background&width=800&height=300&seq=7&orientation=landscape" alt="JavaScript Events" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">addEventListener メソッド</h4>
<div class="mt-2 code-block">
<pre>// ボタンクリックイベントのリスナーを追加
const button = document.getElementById("myButton");
button.addEventListener("click", function(event) {
console.log("ボタンがクリックされました！");
console.log(event); // イベントオブジェクト
});
// 名前付き関数を使用
function handleClick(event) {
console.log("ボタンがクリックされました！");
}
button.addEventListener("click", handleClick);
// イベントリスナーの削除
button.removeEventListener("click", handleClick);</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">HTML属性でのイベント処理</h4>
<div class="mt-2 code-block">
<pre>&lt;button onclick="handleClick()"&gt;クリック&lt;/button&gt;
&lt;script&gt;
function handleClick() {
console.log("ボタンがクリックされました！");
}
&lt;/script&gt;</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">プロパティとしてのイベントハンドラ</h4>
<div class="mt-2 code-block">
<pre>const button = document.getElementById("myButton");
// onclickプロパティにハンドラを割り当て
button.onclick = function(event) {
console.log("ボタンがクリックされました！");
};
// 注意: この方法では1つのハンドラしか設定できない
// 新しいハンドラを割り当てると、前のハンドラは上書きされる
button.onclick = function(event) {
console.log("新しいハンドラ");
};</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">一般的なイベントタイプ</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">マウスイベント</h4>
<div class="mt-2 code-block">
<pre>const element = document.getElementById("myElement");
// クリック
element.addEventListener("click", function(event) {
console.log("クリックされました");
});
// ダブルクリック
element.addEventListener("dblclick", function(event) {
console.log("ダブルクリックされました");
});
// マウスオーバー
element.addEventListener("mouseover", function(event) {
console.log("マウスが要素上に入りました");
});
// マウスアウト
element.addEventListener("mouseout", function(event) {
console.log("マウスが要素から出ました");
});
// マウスダウン
element.addEventListener("mousedown", function(event) {
console.log("マウスボタンが押されました");
});
// マウスアップ
element.addEventListener("mouseup", function(event) {
console.log("マウスボタンが離されました");
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">キーボードイベント</h4>
<div class="mt-2 code-block">
<pre>const inputElement = document.getElementById("myInput");
// キーが押されたとき
inputElement.addEventListener("keydown", function(event) {
console.log("キーが押されました: " + event.key);
});
// キーが離されたとき
inputElement.addEventListener("keyup", function(event) {
console.log("キーが離されました: " + event.key);
});
// キー入力があったとき（文字入力）
inputElement.addEventListener("keypress", function(event) {
console.log("キー入力がありました: " + event.key);
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">フォームイベント</h4>
<div class="mt-2 code-block">
<pre>const formElement = document.getElementById("myForm");
const inputElement = document.getElementById("myInput");
// フォーム送信
formElement.addEventListener("submit", function(event) {
event.preventDefault(); // デフォルトの送信動作を防止
console.log("フォームが送信されました");
});
// 入力値の変更
inputElement.addEventListener("change", function(event) {
console.log("入力値が変更されました: " + this.value);
});
// 入力中
inputElement.addEventListener("input", function(event) {
console.log("入力中: " + this.value);
});
// フォーカス
inputElement.addEventListener("focus", function(event) {
console.log("入力欄がフォーカスされました");
});
// フォーカスが外れた
inputElement.addEventListener("blur", function(event) {
console.log("入力欄からフォーカスが外れました");
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">ドキュメントとウィンドウのイベント</h4>
<div class="mt-2 code-block">
<pre>// DOMの読み込みが完了したとき
document.addEventListener("DOMContentLoaded", function(event) {
console.log("DOMの読み込みが完了しました");
});
// ページの読み込みが完了したとき（画像やスタイルシートなども含む）
window.addEventListener("load", function(event) {
console.log("ページの読み込みが完了しました");
});
// ウィンドウのサイズが変更されたとき
window.addEventListener("resize", function(event) {
console.log("ウィンドウのサイズが変更されました");
console.log("新しい幅: " + window.innerWidth);
console.log("新しい高さ: " + window.innerHeight);
});
// スクロールしたとき
window.addEventListener("scroll", function(event) {
console.log("スクロール位置: " + window.scrollY);
});</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">イベント伝播とイベントオブジェクト</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">イベント伝播（バブリングとキャプチャリング）</h4>
<div class="mt-2 code-block">
<pre>/*
イベント伝播には2つのフェーズがあります：
1. キャプチャリングフェーズ：イベントがウィンドウから対象要素まで下降
2. バブリングフェーズ：イベントが対象要素からウィンドウまで上昇
*/
// バブリングの例
document.getElementById("parent").addEventListener("click", function(event) {
console.log("親要素がクリックされました");
});
document.getElementById("child").addEventListener("click", function(event) {
console.log("子要素がクリックされました");
// event.stopPropagation(); // バブリングを停止する場合
});
// キャプチャリングの例（第3引数をtrueに設定）
document.getElementById("parent").addEventListener("click", function(event) {
console.log("親要素がクリックされました（キャプチャリングフェーズ）");
}, true);
document.getElementById("child").addEventListener("click", function(event) {
console.log("子要素がクリックされました（キャプチャリングフェーズ）");
}, true);</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">イベントオブジェクト</h4>
<div class="mt-2 code-block">
<pre>document.getElementById("myButton").addEventListener("click", function(event) {
// イベントの種類
console.log(event.type); // "click"
// イベントの対象要素
console.log(event.target); // クリックされた要素
// イベントが発生した座標
console.log("クライアント座標: " + event.clientX + ", " + event.clientY);
console.log("ページ座標: " + event.pageX + ", " + event.pageY);
// イベントが発生した時間
console.log("タイムスタンプ: " + event.timeStamp);
// デフォルトの動作を防止
event.preventDefault();
// イベントの伝播を停止
event.stopPropagation();
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">イベント委任（デリゲーション）</h4>
<p class="mt-2 text-gray-600">多数の要素に同じイベントハンドラを設定する代わりに、親要素に1つのハンドラを設定する手法です。</p>
<div class="mt-2 code-block">
<pre>// 多数のボタンに個別にリスナーを追加する代わりに、
// 親要素にリスナーを1つ追加し、event.targetで判断
document.getElementById("buttonContainer").addEventListener("click", function(event) {
// クリックされた要素がボタンかどうかを確認
if (event.target.tagName === "BUTTON") {
console.log("ボタンがクリックされました: " + event.target.textContent);
// data-* 属性を使用して追加情報を取得
const buttonId = event.target.getAttribute("data-id");
if (buttonId) {
console.log("ボタンID: " + buttonId);
}
}
});</pre>
</div>
</div>
</div>
</div>
</section>
<section id="async-await" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">Async/Await</h2>
<p class="mb-4 leading-relaxed">Async/Awaitは、ES2017（ES8）で導入された非同期処理を扱うための構文です。Promiseベースの非同期コードを、同期的なコードのように書くことができ、より読みやすく保守しやすいコードになります。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">Async/Awaitの基本</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520async%2520await%2520flow%2520diagram%2520showing%2520asynchronous%2520execution%2520sequence%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520highlights%2520on%2520white%2520background&width=800&height=300&seq=8&orientation=landscape" alt="Async Await" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">async関数</h4>
<p class="mt-2 text-gray-600">async関数は常にPromiseを返します。</p>
<div class="mt-2 code-block">
<pre>// asyncキーワードを使用して非同期関数を定義
async function fetchData() {
return "データ";
}
// 返り値は自動的にPromiseでラップされる
fetchData().then(data => {
console.log(data); // "データ"
});
// 明示的にPromiseを返すこともできる
async function fetchMoreData() {
return Promise.resolve("さらにデータ");
}
// エラーをスローすると、Promiseはrejectされる
async function fetchWithError() {
throw new Error("データの取得に失敗しました");
}
fetchWithError().catch(error => {
console.error(error.message); // "データの取得に失敗しました"
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">await演算子</h4>
<p class="mt-2 text-gray-600">await演算子は、Promiseが解決されるまで非同期関数の実行を一時停止します。</p>
<div class="mt-2 code-block">
<pre>async function fetchUserData() {
// Promiseが解決されるまで待機し、その結果を変数に代入
const response = await fetch("https://api.example.com/users");
const data = await response.json();
return data;
}
// 使用例
async function displayUserData() {
try {
const userData = await fetchUserData();
console.log(userData);
} catch (error) {
console.error("ユーザーデータの取得に失敗しました:", error);
}
}
displayUserData();</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">Async/Awaitの利点</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">Promiseチェーンとの比較</h4>
<div class="mt-2 code-block">
<pre>// Promiseチェーンを使用した例
function fetchUserDataWithPromises() {
return fetch("https://api.example.com/users")
.then(response => response.json())
.then(users => {
return fetch(`https://api.example.com/users/${users[0].id}/posts`);
})
.then(response => response.json())
.then(posts => {
return fetch(`https://api.example.com/posts/${posts[0].id}/comments`);
})
.then(response => response.json());
}
// Async/Awaitを使用した例
async function fetchUserDataWithAsync() {
const usersResponse = await fetch("https://api.example.com/users");
const users = await usersResponse.json();
const postsResponse = await fetch(`https://api.example.com/users/${users[0].id}/posts`);
const posts = await postsResponse.json();
const commentsResponse = await fetch(`https://api.example.com/posts/${posts[0].id}/comments`);
const comments = await commentsResponse.json();
return comments;
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">エラーハンドリング</h4>
<div class="mt-2 code-block">
<pre>// Promiseチェーンでのエラーハンドリング
fetchUserDataWithPromises()
.then(comments => {
console.log(comments);
})
.catch(error => {
console.error("エラーが発生しました:", error);
});
// Async/Awaitでのエラーハンドリング
async function fetchAndDisplayData() {
try {
const comments = await fetchUserDataWithAsync();
console.log(comments);
} catch (error) {
console.error("エラーが発生しました:", error);
}
}
fetchAndDisplayData();</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">Async/Awaitの高度な使い方</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">並列処理</h4>
<p class="mt-2 text-gray-600">複数の非同期処理を並列に実行する方法です。</p>
<div class="mt-2 code-block">
<pre>async function fetchMultipleData() {
try {
// Promise.allを使用して複数のリクエストを並列に実行
const [users, posts, comments] = await Promise.all([
fetch("https://api.example.com/users").then(response => response.json()),
fetch("https://api.example.com/posts").then(response => response.json()),
fetch("https://api.example.com/comments").then(response => response.json())
]);
return { users, posts, comments };
} catch (error) {
console.error("データの取得に失敗しました:", error);
throw error;
}
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">ループ内でのAsync/Await</h4>
<div class="mt-2 code-block">
<pre>// 逐次処理（1つずつ順番に処理）
async function processItemsSequentially(items) {
const results = [];
for (const item of items) {
// 各アイテムの処理が完了するのを待ってから次へ
const result = await processItem(item);
results.push(result);
}
return results;
}
// 並列処理（すべて同時に処理）
async function processItemsParallel(items) {
// すべてのアイテムの処理を開始し、Promiseの配列を作成
const promises = items.map(item => processItem(item));
// すべてのPromiseが解決されるのを待機
const results = await Promise.all(promises);
return results;
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">Async/Awaitの制限と注意点</h4>
<div class="mt-2 code-block">
<pre>// トップレベルでのawaitは（モジュール内を除いて）使用できない
// await fetch("https://api.example.com/data"); // エラー
// 即時実行関数を使用する方法
(async function() {
const data = await fetch("https://api.example.com/data").then(res => res.json());
console.log(data);
})();
// または最新のJavaScriptでは、トップレベルawaitがサポートされているモジュール内で使用可能
// script type="module" の中や、.mjs ファイル内など
// const data = await fetch("https://api.example.com/data").then(res => res.json());
// console.log(data);</pre>
</div>
</div>
</div>
</div>
</section>
<section id="modules" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">モジュール</h2>
<p class="mb-4 leading-relaxed">JavaScriptモジュールは、コードを再利用可能な部分に分割し、依存関係を管理するための仕組みです。ES6（ECMAScript 2015）で標準化されたモジュールシステムを使用すると、コードを整理し、保守性を向上させることができます。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">モジュールの基本</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520modules%2520visualization%2520showing%2520code%2520organization%2520and%2520imports%2520exports%2520between%2520files%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520highlights%2520on%2520white%2520background&width=800&height=300&seq=9&orientation=landscape" alt="JavaScript Modules" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">モジュールの作成とエクスポート</h4>
<div class="mt-2 code-block">
<pre>// math.js - モジュールファイル
// 名前付きエクスポート
export function add(a, b) {
return a + b;
}
export function subtract(a, b) {
return a - b;
}
// 変数のエクスポート
export const PI = 3.14159;
// クラスのエクスポート
export class Calculator {
add(a, b) {
return a + b;
}
subtract(a, b) {
return a - b;
}
}
// デフォルトエクスポート（1つのモジュールにつき1つだけ）
export default function multiply(a, b) {
return a * b;
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">モジュールのインポート</h4>
<div class="mt-2 code-block">
<pre>// app.js - モジュールを使用するファイル
// 名前付きインポート
import { add, subtract, PI } from './math.js';
console.log(add(5, 3));      // 8
console.log(subtract(5, 3)); // 2
console.log(PI);             // 3.14159
// デフォルトインポート
import multiply from './math.js';
console.log(multiply(5, 3)); // 15
// 名前付きとデフォルトを一緒にインポート
import multiply, { add, subtract } from './math.js';
// 名前を変更してインポート
import { add as addition, subtract as subtraction } from './math.js';
console.log(addition(5, 3));      // 8
console.log(subtraction(5, 3));   // 2
// モジュール全体をオブジェクトとしてインポート
import * as MathModule from './math.js';
console.log(MathModule.add(5, 3));      // 8
console.log(MathModule.PI);             // 3.14159
console.log(MathModule.default(5, 3));  // 15 (デフォルトエクスポートは'default'プロパティ)</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">モジュールの使用方法</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">ブラウザでのモジュールの使用</h4>
<div class="mt-2 code-block">
<pre>&lt;!-- HTMLでモジュールを読み込む --&gt;
&lt;script type="module" src="app.js"&gt;&lt;/script&gt;
&lt;!-- インラインモジュールスクリプト --&gt;
&lt;script type="module"&gt;
import { add } from './math.js';
console.log(add(5, 3)); // 8
&lt;/script&gt;</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">Node.jsでのモジュールの使用</h4>
<div class="mt-2 code-block">
<pre>// package.jsonに "type": "module" を追加するか、
// ファイル拡張子を .mjs にする
// math.mjs
export function add(a, b) {
return a + b;
}
// app.mjs
import { add } from './math.mjs';
console.log(add(5, 3)); // 8</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">動的インポート</h4>
<p class="mt-2 text-gray-600">必要に応じてモジュールを動的に読み込むことができます。</p>
<div class="mt-2 code-block">
<pre>// ボタンクリック時にモジュールを動的に読み込む
document.getElementById("loadButton").addEventListener("click", async () => {
try {
// import() はPromiseを返す
const mathModule = await import('./math.js');
console.log(mathModule.add(5, 3)); // 8
} catch (error) {
console.error("モジュールの読み込みに失敗しました:", error);
}
});</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">モジュールの高度な使い方</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">モジュールの集約と再エクスポート</h4>
<div class="mt-2 code-block">
<pre>// utils/math.js
export function add(a, b) {
return a + b;
}
export function subtract(a, b) {
return a - b;
}
// utils/string.js
export function capitalize(str) {
return str.charAt(0).toUpperCase() + str.slice(1);
}
// utils/index.js - 複数のモジュールを集約して再エクスポート
export { add, subtract } from './math.js';
export { capitalize } from './string.js';
export * from './array.js'; // モジュール内のすべてをエクスポート
// app.js - 集約されたモジュールからインポート
import { add, capitalize } from './utils/index.js';
// または
import { add, capitalize } from './utils'; // index.jsは省略可能</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">循環依存の問題と解決策</h4>
<div class="mt-2 code-block">
<pre>// moduleA.js
import { functionB } from './moduleB.js';
export function functionA() {
console.log("Function A");
functionB();
}
// moduleB.js
import { functionA } from './moduleA.js';
export function functionB() {
console.log("Function B");
// functionA(); // これを呼び出すと循環依存が発生
}
// 解決策1: 依存関係を再構成する
// 解決策2: 動的インポートを使用する
// moduleB.js
export function functionB() {
console.log("Function B");
import('./moduleA.js').then(moduleA => {
moduleA.functionA();
});
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">モジュールの初期化と副作用</h4>
<div class="mt-2 code-block">
<pre>// config.js
console.log("設定を読み込んでいます...");
// 設定の初期化（モジュールが最初にインポートされたときに1回だけ実行される）
const config = {
apiUrl: "https://api.example.com",
timeout: 5000
};
// 設定を変更する関数
export function updateConfig(newConfig) {
Object.assign(config, newConfig);
}
// 設定を取得する関数
export function getConfig() {
return { ...config }; // コピーを返して直接変更を防ぐ
}
// app.js
import { getConfig, updateConfig } from './config.js';
// "設定を読み込んでいます..." が出力される（最初のインポート時のみ）
console.log(getConfig()); // { apiUrl: "https://api.example.com", timeout: 5000 }
updateConfig({ timeout: 10000 });
console.log(getConfig()); // { apiUrl: "https://api.example.com", timeout: 10000 }
// otherModule.js
import { getConfig } from './config.js';
// "設定を読み込んでいます..." は出力されない（モジュールは既に初期化済み）
console.log(getConfig()); // { apiUrl: "https://api.example.com", timeout: 10000 }</pre>
</div>
</div>
</div>
</div>
</section>
<section id="error-handling" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">エラー処理</h2>
<p class="mb-4 leading-relaxed">エラー処理は、プログラムの実行中に発生する可能性のある問題を適切に管理するための重要な部分です。JavaScriptでは、try...catch文やエラーオブジェクトを使用して、エラーを捕捉し、処理することができます。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">エラー処理の基本</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520error%2520handling%2520visualization%2520showing%2520try%2520catch%2520blocks%2520and%2520error%2520propagation%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520highlights%2520on%2520white%2520background&width=800&height=300&seq=10&orientation=landscape" alt="Error Handling" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">try...catch文</h4>
<div class="mt-2 code-block">
<pre>try {
// エラーが発生する可能性のあるコード
const result = someFunction();
console.log(result);
} catch (error) {
// エラーが発生した場合に実行されるコード
console.error("エラーが発生しました:", error.message);
} finally {
// エラーの有無に関わらず実行されるコード
console.log("処理が完了しました");
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">エラーオブジェクト</h4>
<div class="mt-2 code-block">
<pre>try {
// 存在しない変数を参照
console.log(undefinedVariable);
} catch (error) {
console.error("エラータイプ:", error.name);    // "ReferenceError"
console.error("エラーメッセージ:", error.message); // "undefinedVariable is not defined"
console.error("スタックトレース:", error.stack);   // エラーが発生した場所の情報
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">エラーの種類</h4>
<div class="mt-2 code-block">
<pre>// ReferenceError: 存在しない変数を参照した場合
try {
console.log(undefinedVariable);
} catch (error) {
console.error(error.name); // "ReferenceError"
}
// SyntaxError: 構文エラー（通常はコンパイル時に検出されるため、try-catchでは捕捉できない）
// try {
//   eval("console.log('Hello world'");
// } catch (error) {
//   console.error(error.name); // "SyntaxError"
// }
// TypeError: 値が期待される型でない場合
try {
const num = 123;
num.toUpperCase();
} catch (error) {
console.error(error.name); // "TypeError"
}
// RangeError: 値が許容範囲外の場合
try {
const arr = new Array(-1);
} catch (error) {
console.error(error.name); // "RangeError"
}</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">カスタムエラーとエラーの投げ方</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">throw文</h4>
<div class="mt-2 code-block">
<pre>function divide(a, b) {
if (b === 0) {
throw new Error("0で除算することはできません");
}
return a / b;
}
try {
const result = divide(10, 0);
console.log(result);
} catch (error) {
console.error("エラーが発生しました:", error.message);
// "エラーが発生しました: 0で除算することはできません"
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">カスタムエラークラス</h4>
<div class="mt-2 code-block">
<pre>// カスタムエラークラスの定義
class ValidationError extends Error {
constructor(message) {
super(message);
this.name = "ValidationError";
}
}
class DatabaseError extends Error {
constructor(message, code) {
super(message);
this.name = "DatabaseError";
this.code = code;
}
}
// カスタムエラーの使用
function validateUser(user) {
if (!user.name) {
throw new ValidationError("ユーザー名は必須です");
}
if (!user.email) {
throw new ValidationError("メールアドレスは必須です");
}
}
try {
validateUser({ name: "山田太郎" });
} catch (error) {
if (error instanceof ValidationError) {
console.error("バリデーションエラー:", error.message);
} else if (error instanceof DatabaseError) {
console.error(`データベースエラー (${error.code}):`, error.message);
} else {
console.error("予期しないエラー:", error);
}
}</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">非同期処理のエラーハンドリング</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">Promiseのエラーハンドリング</h4>
<div class="mt-2 code-block">
<pre>// .catchを使用したエラーハンドリング
fetchData()
.then(data => {
console.log("データ:", data);
})
.catch(error => {
console.error("データの取得に失敗しました:", error);
})
.finally(() => {
console.log("処理が完了しました");
});
// Promiseチェーンでのエラーハンドリング
fetchData()
.then(data => {
// この処理でエラーが発生した場合
return processData(data);
})
.then(processedData => {
// 前の処理でエラーが発生した場合、この処理はスキップされる
console.log("処理済みデータ:", processedData);
})
.catch(error => {
// チェーン内のどこかでエラーが発生した場合にここで捕捉される
console.error("エラーが発生しました:", error);
});</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">Async/Awaitのエラーハンドリング</h4>
<div class="mt-2 code-block">
<pre>// try...catchを使用したエラーハンドリング
async function fetchAndProcessData() {
try {
const data = await fetchData();
const processedData = await processData(data);
console.log("処理済みデータ:", processedData);
} catch (error) {
console.error("エラーが発生しました:", error);
} finally {
console.log("処理が完了しました");
}
}
// 複数の非同期処理のエラーハンドリング
async function fetchMultipleData() {
try {
// Promise.allは、いずれかのPromiseがrejectされるとすぐにrejectされる
const [users, posts] = await Promise.all([
fetchUsers(),
fetchPosts()
]);
console.log("ユーザー:", users);
console.log("投稿:", posts);
} catch (error) {
console.error("データの取得に失敗しました:", error);
}
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">グローバルなエラーハンドリング</h4>
<div class="mt-2 code-block">
<pre>// 未処理のPromiseエラーをキャッチ
window.addEventListener("unhandledrejection", event => {
console.error("未処理のPromiseエラー:", event.reason);
event.preventDefault(); // ブラウザのデフォルトのエラーログを抑制
});
// グローバルなエラーハンドラ
window.onerror = function(message, source, lineno, colno, error) {
console.error("グローバルエラー:", {
message,
source,
lineno,
colno,
error
});
// trueを返すと、ブラウザのデフォルトのエラーログを抑制
return true;
};</pre>
</div>
</div>
</div>
</div>
</section>
<section id="best-practices" class="mb-10">
<h2 class="text-3xl font-bold text-gray-800 mb-4">ベストプラクティス</h2>
<p class="mb-4 leading-relaxed">JavaScriptコードを書く際には、一貫性、可読性、保守性を高めるためのベストプラクティスに従うことが重要です。以下では、JavaScriptプログラミングにおける主要なベストプラクティスを紹介します。</p>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">コーディング規約とスタイル</h3>
<div class="mb-6">
<img src="https://readdy.ai/api/search-image?query=javascript%2520best%2520practices%2520visualization%2520showing%2520clean%2520code%2520principles%2520and%2520organization%252C%2520modern%2520programming%2520concept%2520illustration%2520with%2520blue%2520highlights%2520on%2520white%2520background&width=800&height=300&seq=11&orientation=landscape" alt="JavaScript Best Practices" class="w-full h-[200px] object-cover rounded-lg mb-4">
</div>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">変数と命名規則</h4>
<div class="mt-2 code-block">
<pre>// 良い例
const firstName = "太郎";
const isActive = true;
const MAX_SIZE = 100;
// キャメルケースを使用（変数、関数）
const getUserData = () => { /* ... */ };
// パスカルケースを使用（クラス、コンストラクタ）
class UserProfile { /* ... */ }
// 定数には大文字とアンダースコアを使用
const API_BASE_URL = "https://api.example.com";
// 悪い例
const fn = "太郎";  // 意味が不明確
const a = true;     // 意味が不明確
const s = 100;      // 意味が不明確</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">インデントとフォーマット</h4>
<div class="mt-2 code-block">
<pre>// 一貫したインデント（スペース2つまたは4つ）
function calculateTotal(items) {
let total = 0;
for (const item of items) {
total += item.price;
}
return total;
}
// 適切な空白と改行
const person = {
firstName: "太郎",
lastName: "山田",
age: 30,
address: {
street: "桜木町1-2-3",
city: "東京"
}
};
// 演算子の周りに空白を入れる
const sum = a + b;
const isEqual = a === b;</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">コメント</h4>
<div class="mt-2 code-block">
<pre>/**
* ユーザーデータを取得する関数
* @param {number} userId - ユーザーID
* @returns {Promise<Object>} ユーザーデータ
*/
async function fetchUserData(userId) {
// APIからユーザーデータを取得
const response = await fetch(`https://api.example.com/users/${userId}`);
// レスポンスが正常でない場合はエラーをスロー
if (!response.ok) {
throw new Error(`ユーザーデータの取得に失敗しました: ${response.status}`);
}
return response.json();
}</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
<h3 class="text-xl font-semibold text-gray-800 mb-4">コードの品質と保守性</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">DRY原則（Don't Repeat Yourself）</h4>
<div class="mt-2 code-block">
<pre>// 悪い例: コードの重複
function validateEmail(email) {
const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
return regex.test(email);
}
function validateForm() {
const email = document.getElementById("email").value;
const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
if (!regex.test(email)) {
showError("無効なメールアドレスです");
}
}
// 良い例: 共通の機能を関数に抽出
function validateEmail(email) {
const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
return regex.test(email);
}
function validateForm() {
const email = document.getElementById("email").value;
if (!validateEmail(email)) {
showError("無効なメールアドレスです");
}
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">単一責任の原則</h4>
<div class="mt-2 code-block">
<pre>// 悪い例: 1つの関数が複数の責任を持つ
function processUserData(userData) {
// データの検証
if (!userData.name || !userData.email) {
throw new Error("無効なユーザーデータです");
}
// データの変換
const processedData = {
fullName: `${userData.lastName} ${userData.firstName}`,
email: userData.email.toLowerCase(),
isActive: true
};
// データの保存
saveToDatabase(processedData);
// メール送信
sendWelcomeEmail(processedData.email);
return processedData;
}
// 良い例: 責任を分割
function validateUserData(userData) {
if (!userData.name || !userData.email) {
throw new Error("無効なユーザーデータです");
}
return true;
}
function transformUserData(userData) {
return {
fullName: `${userData.lastName} ${userData.firstName}`,
email: userData.email.toLowerCase(),
isActive: true
};
}
function processUserData(userData) {
validateUserData(userData);
const processedData = transformUserData(userData);
saveToDatabase(processedData);
sendWelcomeEmail(processedData.email);
return processedData;
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">早期リターン</h4>
<div class="mt-2 code-block">
<pre>// 悪い例: ネストが深い
function processOrder(order) {
if (order) {
if (order.items && order.items.length > 0) {
if (order.paymentStatus === "completed") {
// 注文処理のロジック
return true;
} else {
return false;
}
} else {
return false;
}
} else {
return false;
}
}
// 良い例: 早期リターンでネストを減らす
function processOrder(order) {
if (!order) return false;
if (!order.items || order.items.length === 0) return false;
if (order.paymentStatus !== "completed") return false;
// 注文処理のロジック
return true;
}</pre>
</div>
</div>
</div>
</div>
<div class="bg-gray-50 p-6 rounded-lg border border-gray-200">
<h3 class="text-xl font-semibold text-gray-800 mb-4">パフォーマンスとセキュリティ</h3>
<div class="space-y-4">
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">パフォーマンスの最適化</h4>
<div class="mt-2 code-block">
<pre>// 悪い例: ループ内でDOM操作を繰り返す
function addItems(items) {
const list = document.getElementById("itemList");
for (const item of items) {
const li = document.createElement("li");
li.textContent = item.name;
list.appendChild(li); // 毎回DOMを更新
}
}
// 良い例: DocumentFragmentを使用
function addItems(items) {
const list = document.getElementById("itemList");
const fragment = document.createDocumentFragment();
for (const item of items) {
const li = document.createElement("li");
li.textContent = item.name;
fragment.appendChild(li);
}
list.appendChild(fragment); // DOMの更新は1回だけ
}
// 良い例: 配列操作の最適化
// 悪い例
let result = [];
for (let i = 0; i < 1000; i++) {
result.push(i * 2);
}
// 良い例
let result = Array(1000).fill().map((_, i) => i * 2);</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">セキュリティの考慮事項</h4>
<div class="mt-2 code-block">
<pre>// 悪い例: eval()の使用
function calculateExpression(expression) {
return eval(expression); // セキュリティリスク
}
// 良い例: 安全な代替手段
function calculateExpression(expression) {
// 安全な計算ライブラリを使用するか、
// 独自の式パーサーを実装する
return Function('"use strict";return (' + expression + ')')();
}
// 悪い例: innerHTML
function displayUserMessage(message) {
document.getElementById("output").innerHTML = message; // XSS脆弱性
}
// 良い例: textContent
function displayUserMessage(message) {
document.getElementById("output").textContent = message; // 安全
}
// 悪い例: 信頼できないデータをURLに直接使用
function redirectToUser(userId) {
window.location.href = "https://example.com/users/" + userId; // インジェクションリスク
}
// 良い例: encodeURIComponent
function redirectToUser(userId) {
window.location.href = "https://example.com/users/" + encodeURIComponent(userId);
}</pre>
</div>
</div>
<div class="bg-white p-4 rounded border border-gray-300">
<h4 class="font-mono text-primary">デバッグとテスト</h4>
<div class="mt-2 code-block">
<pre>// デバッグ用のログ
function processData(data) {
console.log("処理開始:", data);
try {
// データ処理のロジック
const result = transformData(data);
console.log("処理結果:", result);
return result;
} catch (error) {
console.error("処理エラー:", error);
throw error;
}
}
// 単体テストの例（Jest風の構文）
describe("数学関数のテスト", () => {
test("add関数は2つの数値を正しく足し合わせる", () => {
expect(add(1, 2)).toBe(3);
expect(add(-1, 1)).toBe(0);
expect(add(0, 0)).toBe(0);
});
test("subtract関数は正しく減算を行う", () => {
expect(subtract(5, 2)).toBe(3);
expect(subtract(2, 5)).toBe(-3);
});
});</pre>
</div>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
<script id="smooth-scroll-script">
document.addEventListener('DOMContentLoaded', function() {
const sidebarLinks = document.querySelectorAll('.sidebar-link');
sidebarLinks.forEach(link => {
link.addEventListener('click', function(e) {
e.preventDefault();
const targetId = this.getAttribute('href').substring(1);
const targetElement = document.getElementById(targetId);
if (targetElement) {
targetElement.scrollIntoView({
behavior: 'smooth',
block: 'start'
});
// On mobile, close the sidebar after clicking a link
if (window.innerWidth < 768) {
document.getElementById('sidebar').classList.remove('open');
}
}
});
});
});
</script>
<script id="mobile-menu-script">
document.addEventListener('DOMContentLoaded', function() {
const mobileMenuButton = document.getElementById('mobile-menu-button');
const closeSidebarButton = document.getElementById('close-sidebar');
const sidebar = document.getElementById('sidebar');
mobileMenuButton.addEventListener('click', function() {
sidebar.classList.add('open');
});
closeSidebarButton.addEventListener('click', function() {
sidebar.classList.remove('open');
});
});
</script>
<script id="sidebar-links-script">
document.addEventListener('DOMContentLoaded', function() {
const sidebarLinks = document.querySelectorAll('.sidebar-link');
sidebarLinks.forEach(link => {
link.addEventListener('click', function() {
// Remove active class from all links
sidebarLinks.forEach(l => l.classList.remove('active'));
// Add active class to clicked link
this.classList.add('active');
// On mobile, close the sidebar after clicking a link
if (window.innerWidth < 768) {
document.getElementById('sidebar').classList.remove('open');
}
});
});
});
</script>
<script id="code-execution-script">
document.addEventListener('DOMContentLoaded', function() {
// Code for interactive examples could be added here
// For example, a simple counter demo or a live code execution environment
});
</script>
</body>
</html>